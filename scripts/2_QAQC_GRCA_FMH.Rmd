---
title: "Grand Canyon QAQC for FMH Data"
author: "Alexandra Lalor"
date: "2024-11-06"
output:
  html_document:
    theme: readable
    highlight: 
    toc: yes
    toc_depth: 3
    toc_float:
      smooth_scroll: yes
  pdf_document:
    toc: yes
    toc_depth: '3'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

# Install packages (if needed)
# install.packages("tidyverse")
# install.packages("Rtools")
```

# BEFORE STARTING

### Load Packages

```{r}
# Load packages
library(tidyverse)
library(writexl)
library(dplyr)
library(knitr)
```

### Adjust File Paths

Make sure to update file paths to be specific for your data.

```{r}
# Identify working directory (specifically user name)
getwd()

# Load in data. Change file path based on user name!
#path_data <- "C:/Users/alalor.NPS/OneDrive - DOI/Desktop/R/GRCA/data/qaqc/2024/"
#path_errors <- "C:/Users/alalor.NPS/OneDrive - DOI/Desktop/R/GRCA/output/errors/2024/"
path_data <- "C:/Users/allie/OneDrive/Desktop/R Projects/GRCA/data/qaqc/2024/"
#path_errors <- "C:/Users/allie/OneDrive/Desktop/R Projects/GRCA/output/errors/2024/"
#path_data <- "C:/Users/alalor.NPS/OneDrive - DOI/Desktop/R/GRCA/data/qaqc/AllYears/"
```

### Load Data

```{r}
# Blank data frame for no errors
errors_blank <- data.frame("SavedQuery" = "","MacroPlot.Name" = "","Date" = "","Error" = "No Error", "Comment" = "")
```

```{r}
# Load in data
Fuels1000_all <- read.csv(paste0(path_data, "GRCA_FMH_2024_Surface Fuels - 1000Hr_XPT.csv"))
FuelsDuffLitt_all <- read.csv(paste0(path_data, "GRCA_FMH_2024_Surface Fuels - Duff_Litter_XPT.csv"))
FuelsFine_all <- read.csv(paste0(path_data, "GRCA_FMH_2024_Surface Fuels - Fine_XPT.csv"))
HerbsPoints_all <- read.csv(paste0(path_data, "Cover - Points (metric)_XPT.csv"))
HerbsObs_all <- read.csv(paste0(path_data, "Cover - Species Composition (metric)_XPT.csv"))
Shrubs_all <- read.csv(paste0(path_data, "Density - Belts (metric)_XPT.csv"))
Seedlings_all <- read.csv(paste0(path_data, "Density - Quadrats (metric)_XPT.csv"))
Trees_all <- read.csv(paste0(path_data, "Trees - Individuals (metric)_XPT.csv"))
#PostBurn_all <- read.csv(paste0(path_data, "Post Burn Severity_XPT.csv"))

# PostBurn_all <- read.csv("C:/Users/allie/OneDrive/Desktop/R Projects/GRCA/data/qaqc/AllYears/I&M_Post Burn Severity_XPT.csv")
```

### Check Data

Fuels1000

```{r}
# Ensure blanks in Visited column are NA
Fuels1000_all$Visited[Fuels1000_all$Visited==""] <- NA

# Clean up data frame
Fuels1000_all <- Fuels1000_all %>%
  # Separate Date column into Date and Time columns
  separate(Date, sep = " ", into = c("Date", "Time")) %>%
  # Separate MacroPlotName to get Monitoring type (or export data with Monitoring Type already included)
  separate(MacroPlot.Name, sep = " ", into = c("MonitoringType", "Plot"), remove = FALSE)

# Filter for only data
Fuels1000_data <- Fuels1000_all %>%
  filter(is.na(Visited))

# Filter for only headers
Fuels1000_header <- Fuels1000_all %>%
  filter(!is.na(Visited))
```

FuelsDuffLitt

```{r}
# Ensure blanks in Visited column are NA 
FuelsDuffLitt_all$Visited[FuelsDuffLitt_all$Visited==""] <- NA  

# Clean up data frame 
FuelsDuffLitt_all <- FuelsDuffLitt_all %>%   
  # Separate Date column into Date and Time columns   
  separate(Date, sep = " ", into = c("Date", "Time")) %>%   
  # Separate MacroPlotName to get Monitoring type (or export data with Monitoring Type already included)   
  separate(MacroPlot.Name, sep = " ", into = c("MonitoringType", "Plot"), remove = FALSE)

# Filter for only data 
FuelsDuffLitt_data <- FuelsDuffLitt_all %>%   
  filter(is.na(Visited))  

# Filter for only headers 
FuelsDuffLitt_header <- FuelsDuffLitt_all %>%   
  filter(!is.na(Visited))
```

FuelsFine

```{r}
# Ensure blanks in Visited column are NA 
FuelsFine_all$Visited[FuelsFine_all$Visited==""] <- NA  

# Clean up data frame 
FuelsFine_all <- FuelsFine_all %>%   
  # Separate Date column into Date and Time columns   
  separate(Date, sep = " ", into = c("Date", "Time")) %>%   
  # Separate MacroPlotName to get Monitoring type (or export data with Monitoring Type already included)   
  separate(MacroPlot.Name, sep = " ", into = c("MonitoringType", "Plot"), remove = FALSE)

# Filter for only data 
FuelsFine_data <- FuelsFine_all %>%   
  filter(is.na(Visited))  

# Filter for only headers 
FuelsFine_header <- FuelsFine_all %>%   
  filter(!is.na(Visited))
```

HerbsPoints

```{r}
# Ensure blanks in Visited column are NA 
HerbsPoints_all$Visited[HerbsPoints_all$Visited==""] <- NA  

# Clean up data frame 
HerbsPoints_all <- HerbsPoints_all %>%   
  # Separate Date column into Date and Time columns   
  separate(Date, sep = " ", into = c("Date", "Time")) %>%   
  # Separate MacroPlotName to get Monitoring type (or export data with Monitoring Type already included)   
  separate(MacroPlot.Name, sep = " ", into = c("MonitoringType", "Plot"), remove = FALSE) 

# Filter for only data 
HerbsPoints_data <- HerbsPoints_all %>%   
  filter(is.na(Visited))  

# Filter for only headers 
HerbsPoints_header <- HerbsPoints_all %>%   
  filter(!is.na(Visited))
```

HerbsObs

```{r}
# Ensure blanks in Visited column are NA 
HerbsObs_all$Visited[HerbsObs_all$Visited==""] <- NA  

# Clean up data frame 
HerbsObs_all <- HerbsObs_all %>%   
  # Separate Date column into Date and Time columns   
  separate(Date, sep = " ", into = c("Date", "Time")) %>%   
  # Separate MacroPlotName to get Monitoring type (or export data with Monitoring Type already included)   
  separate(MacroPlot.Name, sep = " ", into = c("MonitoringType", "Plot"), remove = FALSE) 

# Filter for only data 
HerbsObs_data <- HerbsObs_all %>%   
  filter(is.na(Visited))  

# Filter for only headers 
HerbsObs_header <- HerbsObs_all %>%   
  filter(!is.na(Visited))
```

Shrubs

```{r}
# Ensure blanks in Visited column are NA 
Shrubs_all$Visited[Shrubs_all$Visited==""] <- NA  

# Clean up data frame 
Shrubs_all <- Shrubs_all %>%   
  # Separate Date column into Date and Time columns   
  separate(Date, sep = " ", into = c("Date", "Time")) %>%   
  # Separate MacroPlotName to get Monitoring type (or export data with Monitoring Type already included)   
  separate(MacroPlot.Name, sep = " ", into = c("MonitoringType", "Plot"), remove = FALSE)

# Filter for only data 
Shrubs_data <- Shrubs_all %>%   
  filter(is.na(Visited))  

# Filter for only headers 
Shrubs_header <- Shrubs_all %>%   
  filter(!is.na(Visited))
```

Seedlings

```{r}
# Ensure blanks in Visited column are NA 
Seedlings_all$Visited[Seedlings_all$Visited==""] <- NA  

# Clean up data frame 
Seedlings_all <- Seedlings_all %>%   
  # Separate Date column into Date and Time columns   
  separate(Date, sep = " ", into = c("Date", "Time")) %>%   
  # Separate MacroPlotName to get Monitoring type (or export data with Monitoring Type already included)   
  separate(MacroPlot.Name, sep = " ", into = c("MonitoringType", "Plot"), remove = FALSE) 

# Filter for only data 
Seedlings_data <- Seedlings_all %>%   
  filter(is.na(Visited))  

# Filter for only headers 
Seedlings_header <- Seedlings_all %>%   
  filter(!is.na(Visited))
```

Trees

```{r}
# Ensure blanks in Visited column are NA 
Trees_all$Visited[Trees_all$Visited==""] <- NA  

# Clean up data frame 
Trees_all <- Trees_all %>%   
  # Separate Date column into Date and Time columns   
  separate(Date, sep = " ", into = c("Date", "Time")) %>%   
  # Separate MacroPlotName to get Monitoring type (or export data with Monitoring Type already included)   
  separate(MacroPlot.Name, sep = " ", into = c("MonitoringType", "Plot"), remove = FALSE) 

# Filter for only data 
Trees_data <- Trees_all %>%   
  filter(is.na(Visited))  

# Filter for only headers 
Trees_header <- Trees_all %>%   
  filter(!is.na(Visited))
```

PostBurn

```{r}
# Ensure blanks in Visited column are NA
PostBurn_all$Visited[PostBurn_all$Visited==""] <- NA

# Clean up data frame
PostBurn_all <- PostBurn_all %>%
  # Separate Date column into Date and Time columns
  separate(Date, sep = " ", into = c("Date", "Time")) %>%
  # Separate MacroPlotName to get Monitoring type (or export data with Monitoring Type already included)
  separate(MacroPlot.Name, sep = " ", into = c("MonitoringType", "Plot"), remove = FALSE)

# Filter for only data
PostBurn_data <- PostBurn_all %>%
  filter(is.na(Visited))

# Filter for only headers
PostBurn_header <- PostBurn_all %>%
  filter(!is.na(Visited))
```

# FUNCTIONS

```{r}
# QAQC function
qaqc <- function(data, query, query_message, values_check) {
  # Identify errors 
  errors <- data %>%   
    mutate("SavedQuery" = query, 
           "Error" = paste(query_message, "=", values_data)) %>%   
    # Data is equal exactly to a value
    filter((values_check) %>% replace_na(TRUE)) %>%   
    select("SavedQuery", "MacroPlot.Name", "Date", "Error", "Comment")
  
  # If no errors, add "No Errors" to existing data frame 
  if (nrow(errors) == 0) {   
    errors <- errors_blank %>%     
      mutate(SavedQuery = query) 
  } else {   
    errors <- errors
  }
}
```

# PROTOCOL - SURFACE FUELS

## 1000HR CWD

This code conducts quality control checks on surface fuels data within the surface fuels coarse woody debris (1000-hr) data set.

It checks for: header info (number of transects, length of transects), decay class values, fuel constants, duplicate values, transect numbers, reasonable slope numbers, reasonable diameter values.

### Fuel 1000 Header

[Problem:]{.underline} Incorrect header information entered for FMH plots.

[Procedure:]{.underline}

-   Check that NumTran = 4

```{r}
# Set parameters 
data <- Fuels1000_header
query <- "Fuel 1000 Header NumTran"
query_message <- "Number of Transects" 
values_data <- data$NumTran
values_valid <- 4
values_check <- !values_data == values_valid

# Identify errors
errors_Fuels1000_NumTran <- qaqc(data, query, query_message, values_check)
```

-   Check that North Rim TranLen = 50 (or very close). North Rim plots include PIAB, PIEN, and PIPN.

```{r}
# Set parameters 
data <- Fuels1000_header %>% 
  filter(MonitoringType %in% c("PIAB", "PIEN", "PIPN"))
query <- "Fuel 1000 Header NRim TranLen" 
query_message <- "Transect Length" 
values_data <- data$TranLen 
values_valid <- 50  
values_check <-!values_data == values_valid

# Identify errors
errors_Fuels1000_TranLen_N <- qaqc(data, query, query_message, values_check)
```

-   Check that S Rim TranLen = 100 (or very close). South Rim plots include PIED and PIPO.

```{r}
# Set parameters 
data <- Fuels1000_header %>% 
  filter(MonitoringType %in% c("PIED", "PIPO"))
query <- "Fuel 1000 Header SRim TranLen" 
query_message <- "Transect Length" 
values_data <- data$TranLen 
values_valid <- 100 
values_check <- !values_data == values_valid

# Identify errors
errors_Fuels1000_TranLen_S <- qaqc(data, query, query_message, values_check)
```

### Fuel 1000 DecayClass

[Problem:]{.underline} Logs have an entry for decay class that we don’t use.

[Procedure:]{.underline}

-   Check that DecayCl = 3 or 4

```{r}
# Set parameters
data <- Fuels1000_data
query <- "Fuel 1000 DecayClass"
query_message <- "Decay Class"
values_data <- data$DecayCl
values_valid <- c(3,4)
values_check <- !values_data %in% values_valid

# Identify errors
errors_Fuels1000_DecayCl <- qaqc(data, query, query_message, values_check)
```

### Fuel 1000 FuelConst

[Problem:]{.underline} Incorrect coarse woody debris fuel constant entered for PIAB or PIED or PIEN or PIPN or PIPO. Fuel constant name should correspond to the Monitoring Type.

[Procedure:]{.underline}

-   Check that CWDFuConSt = Monitoring Type

```{r}
# Set parameters
data <- Fuels1000_data
query <- "Fuel 1000 FuelConst"
query_message <- "Fuel Constant"
values_data <- data$CWDFuConSt
values_valid <- data$MonitoringType
values_check <- !values_data == values_valid

# Identify errors
errors_Fuels1000_FuelConst <- qaqc(data, query, query_message, values_check)
```

### Fuel 1000 LogNo

[Problem:]{.underline} "Duplicate" data exists due to multiple 1000 hr fuels with the same transect / diameter / decay class. Log Numbers are missing (which would differentiate 1000 hr fuels).

[Procedure:]{.underline}

-   Check for duplication (TRUE/FALSE) and store results in new column

-   Check for TRUE values

```{r}
# Remove Index. Check for duplication (TRUE/FALSE) and store results in new column
data_temp <- Fuels1000_data %>%
  select(!"Index")

# Set parameters 
data <- data_temp %>%
  mutate("Duplicate" = duplicated(data_temp))
query <- "Fuel 1000 LogNo" 
query_message <- "Duplicate Logs" 
values_data <- data$Duplicate
values_valid <- FALSE
values_check <- !values_data == values_valid

# Identify errors
errors_Fuels1000_LogNo <- qaqc(data, query, query_message, values_check)
```

### Fuel 1000 Values

[Problem:]{.underline}  Values for transect, slope, and diameter are missing or unreasonable.

[Procedure:]{.underline}

-   Check that Transect = 1, 2, 3, or 4

```{r}
# Set parameters
data <- Fuels1000_data
query <- "Fuel 1000 Values TransNum"
query_message <- "Transect Number"
values_data <- data$Transect
values_valid <- c(1, 2, 3, 4)
values_check <- !values_data %in% values_valid

# Identify errors
errors_Fuels1000_TransNum <- qaqc(data, query, query_message, values_check)
```

-   Check that Slope values are reasonable.

```{r}
# Set parameters
data <- Fuels1000_data
query <- "Fuel 1000 Values Slope"
query_message <- "Slope"
values_data <- data$Slope
values_valid <- seq(0, 90, by = 1)
values_check <- (!values_data %in% values_valid) %>% replace_na(TRUE)

# Identify errors
errors_Fuels1000_Slope <- qaqc(data, query, query_message, values_check)
```

-   Check that diameter values are reasonable, are measured at 0.5 increments, and ≥ 3.0.

```{r}
# Perform Rosner's Test for outliers.
# This test is most appropriate when the sample size is large (n > 20). 
# Valid values were found by using the Rosner test on the full suite of data.
# Refer to the script 2_QAQC_Rosner.Rmd

# Set parameters
data <- Fuels1000_data
query <- "Fuel 1000 Values Dia"
query_message <- "Diameter"
values_data <- data$Dia
values_valid <- seq(3, 35, by = 0.5)
values_check <- !values_data %in% values_valid

# Identify errors
errors_Fuels1000_Dia <- qaqc(data, query, query_message, values_check)
```

### Fuel 1000 Errors

```{r}
# Save to master error list
errors_Fuels1000 <- rbind(errors_Fuels1000_DecayCl, errors_Fuels1000_FuelConst, 
                          errors_Fuels1000_NumTran, errors_Fuels1000_TranLen_N, 
                          errors_Fuels1000_TranLen_S, errors_Fuels1000_LogNo, 
                          errors_Fuels1000_TransNum, errors_Fuels1000_Slope, 
                          errors_Fuels1000_Dia)

remove(errors_Fuels1000_DecayCl, errors_Fuels1000_FuelConst, errors_Fuels1000_NumTran, 
       errors_Fuels1000_TranLen_N, errors_Fuels1000_TranLen_S, errors_Fuels1000_LogNo,
       errors_Fuels1000_TransNum, errors_Fuels1000_Slope, errors_Fuels1000_Dia)

# Table of results for quick check
kable(errors_Fuels1000, "pipe")

# Save as CSV or XLSX
path_errors
#write.csv(errors_Fuels1000, paste0(path_errors, "errors_Fuels1000.csv"), quote=FALSE, row.names = FALSE, na = "")
#write_xlsx(errors_Fuels1000, paste0(path_errors, "errors_Fuels1000.xlsx"))
```

## DUFF LITTER

This code conducts quality control checks on surface fuels data within the surface fuels duff litter data set.

It checks for: number of transects, fuel constants, number of points sampled, reasonable litter values, reasonable duff values.

### Fuel DL Header

[Problem:]{.underline} Incorrect header information entered for FMH plots.

[Procedure:]{.underline}

-   Check that NumTran = 4

```{r}
# Set parameters  
data <- FuelsDuffLitt_header
query <- "Fuel DL Header NumTran" 
query_message <- "Number of Transects"  
values_data <- data$NumTran  
values_valid <- 4    
values_check <- !values_data == values_valid

# Identify errors
errors_FuelsDuffLitt_NumTran <- qaqc(data, query, query_message, values_check)
```

### Fuel DL FuelConst

[Problem:]{.underline} Incorrect duff & litter fuel constant entered for PIAB or PIED or PIEN or PIPN or PIPO. Fuel constant name should correspond to the Monitoring Type.

[Procedure:]{.underline}

-   Check that DLFuConSt = Monitoring Type

```{r}
# Set parameters 
data <- FuelsDuffLitt_data
query <- "Fuel DL FuelConst" 
query_message <- "Fuel Constant" 
values_data <- data$DLFuConSt 
values_valid <- data$MonitoringType  
values_check <- !values_data == values_valid

# Identify errors
errors_FuelsDuffLitt_FuelConst <- qaqc(data, query, query_message, values_check)

errors_FuelsDuffLitt_FuelConst <- errors_FuelsDuffLitt_FuelConst %>% 
  reframe("SavedQuery" = unique(query),
          "MacroPlot.Name" = unique(MacroPlot.Name), 
          "Date" = unique(Date),
          "Error" = unique(Error),
          "Comment" = unique(Comment)) 
```

### Fuel DL Hits

[Problem:]{.underline} Extra or missing data points in FMH plots. There should be 4 transects with 10 sample points per transect. 

[Procedure:]{.underline}

-   Group by Macroplot. Calculate number of hits per plot. Check that sum_hits = 40

```{r}
# Filter NA values. Add number of hits and store in new column
data_temp <- FuelsDuffLitt_data %>%
  filter(!is.na(SampLoc)) %>% 
  group_by(MacroPlot.Name) %>% 
  summarize("sum_hits" = n())

# Set parameters 
data <- merge(FuelsDuffLitt_data, data_temp, all.x = T)
query <- "Fuel DL Hits" 
query_message <- "Number of Hits" 
values_data <- data$sum_hits
values_valid <- 40
values_check <- !values_data == values_valid

# Identify errors
errors_FuelsDuffLitt_Hits <- qaqc(data, query, query_message, values_check)

errors_FuelsDuffLitt_Hits <- errors_FuelsDuffLitt_Hits %>% 
  reframe("SavedQuery" = unique(query),
          "MacroPlot.Name" = unique(MacroPlot.Name), 
          "Date" = unique(Date),
          "Error" = unique(Error),
          "Comment" = unique(Comment)) 
```

### Fuel DL Values

[Problem:]{.underline}  Values for litter and duff depth are missing or unreasonable.

[Procedure:]{.underline}

-   Sort by LittDep. Check that litter depth values are reasonable.

```{r}
# Perform Rosner's Test for outliers.
# This test is most appropriate when the sample size is large (n > 20). 
# Valid values were found by using the Rosner test on the full suite of data.
# Refer to the script 2_QAQC_Rosner.Rmd

# Set parameters 
data <- FuelsDuffLitt_data
query <- "Fuel DL Values LittDep" 
query_message <- "Litter Depth" 
values_data <- data$LittDep
values_valid <- max(7.6)
values_check <- !values_data <= values_valid

# Identify errors
errors_FuelsDuffLitt_LittDep <- qaqc(data, query, query_message, values_check)
```

-   Sort by DuffDep. Check that duff depth values are reasonable.

```{r}
# Perform Rosner's Test for outliers.
# This test is most appropriate when the sample size is large (n > 20). 
# Valid values were found by using the Rosner test on the full suite of data.
# Refer to the script 2_QAQC_Rosner.Rmd

# Set parameters 
data <- FuelsDuffLitt_data
query <- "Fuel DL Values DuffDep" 
query_message <- "Duff Depth" 
values_data <- data$DuffDep
values_valid <- max(13)
values_check <- !values_data <= values_valid

# Identify errors
errors_FuelsDuffLitt_DuffDep <- qaqc(data, query, query_message, values_check)
```

### Fuel DL Errors

```{r}
# Save to master error list 
errors_FuelsDuffLitt <- rbind(errors_FuelsDuffLitt_FuelConst, errors_FuelsDuffLitt_NumTran,
                              errors_FuelsDuffLitt_Hits, errors_FuelsDuffLitt_LittDep,
                              errors_FuelsDuffLitt_DuffDep)

remove(errors_FuelsDuffLitt_FuelConst, errors_FuelsDuffLitt_NumTran,
       errors_FuelsDuffLitt_Hits, errors_FuelsDuffLitt_LittDep,
       errors_FuelsDuffLitt_DuffDep)

# Table of results for quick check
kable(errors_FuelsDuffLitt, "pipe")

# Save as CSV or XLSX
path_errors
#write.csv(errors_FuelsDuffLitt, paste0(path_errors, "errors_FuelsDuffLitt.csv"), quote=FALSE, row.names = FALSE, na = "")
#write_xlsx(errors_FuelsDuffLitt, paste0(path_errors, "errors_FuelsDuffLitt.xlsx"))
```

## FINE FUELS

This code conducts quality control checks on surface fuels data within the surface fuels fine (FWD) data set.

It checks for: header info (number of transects, length of transects for One/Ten/Hundred Hour), fuel constants, transect numbers, reasonable azimuth numbers, reasonable slope numbers, reasonable One/Ten/Hundred Hour count values.

### Fuel Fine Header

[Problem:]{.underline} Incorrect header information entered for FMH plots.

[Procedure:]{.underline}

-   Check that NumTran = 4

```{r}
# Set parameters  
data <- FuelsFine_header
query <- "Fuel Fine Header NumTran" 
query_message <- "Number of Transects"  
values_data <- data$NumTran  
values_valid <- 4    
values_check <- !values_data == values_valid

# Identify errors
errors_FuelsFine_NumTran <- qaqc(data, query, query_message, values_check)
```

-   Check that OneHrTranLen = 6

```{r}
# Set parameters  
data <- FuelsFine_header
query <- "Fuel Fine Header OneHrTranLen" 
query_message <- "One Hour Transect Length"  
values_data <- data$OneHrTranLen
values_valid <- 6
values_check <- !values_data == values_valid

# Identify errors
errors_FuelsFine_OneHrTranLen <- qaqc(data, query, query_message, values_check)
```

-   Check that TenHrTranLen = 6

```{r}
# Set parameters  
data <- FuelsFine_header
query <- "Fuel Fine Header TenHrTranLen" 
query_message <- "Ten Hour Transect Length"  
values_data <- data$TenHrTranLen 
values_valid <- 6
values_check <- !values_data == values_valid

# Identify errors
errors_FuelsFine_TenHrTranLen <- qaqc(data, query, query_message, values_check)
```

-   Check that HunHrTranLen = 12

```{r}
# Set parameters  
data <- FuelsFine_header
query <- "Fuel Fine Header HunHrTranLen" 
query_message <- "Hundrend Hour Transect Length"  
values_data <- data$HunHrTranLen 
values_valid <- 12
values_check <- !values_data == values_valid

# Identify errors
errors_FuelsFine_HunHrTranLen <- qaqc(data, query, query_message, values_check)
```

### Fuel Fine FuelConst

[Problem:]{.underline} Incorrect fine woody debris fuel constant entered for PIAB or PIED or PIEN or PIPN or PIPO. Fuel constant name should correspond to the Monitoring Type.

[Procedure:]{.underline}

-   Check that FWDFuConSt = Monitoring Type

```{r}
# Set parameters 
data <- FuelsFine_data
query <- "Fuel Fine FuelConst" 
query_message <- "Fuel Constant" 
values_data <- data$FWDFuConSt 
values_valid <- data$MonitoringType  
values_check <- !values_data == values_valid

# Identify errors
errors_FuelsFine_FuelConst <- qaqc(data, query, query_message, values_check)
```

### Fuel Fine Hits

[Problem:]{.underline} Extra or missing data points in FMH plots. There should be 4 transects with 1 sample point per transect. 

[Procedure:]{.underline}

-   Group by Macroplot. Calculate number of hits per plot. Check that sum_hits = 4

```{r}
# Filter NA values. Add number of hits and store in new column
data_temp <- FuelsFine_data %>%
  filter(!is.na(Transect)) %>% 
  group_by(MacroPlot.Name) %>% 
  summarize("sum_hits" = n())

# Set parameters 
data <- merge(FuelsFine_data, data_temp, all.x = T)
query <- "Fuel Fine Hits" 
query_message <- "Number of Hits" 
values_data <- data$sum_hits
values_valid <- 4
values_check <- !values_data == values_valid

# Identify errors
errors_FuelsFine_Hits <- qaqc(data, query, query_message, values_check)

errors_FuelsFine_Hits <- errors_FuelsFine_Hits %>% 
  reframe("SavedQuery" = unique(query),
          "MacroPlot.Name" = unique(MacroPlot.Name), 
          "Date" = unique(Date),
          "Error" = unique(Error),
          "Comment" = "NA") 
```

### Fuel Fine Values

[Problem:]{.underline}  Values for transect, azimuth, slope, and counts for One, Ten, Hundred hour fuels are missing or unreasonable.

[Procedure:]{.underline}

-   Check that Transect = 1, 2, 3, or 4

```{r}
# Set parameters
data <- FuelsFine_data
query <- "Fuel Fine Values TransNum"
query_message <- "Transect Number"
values_data <- data$Transect
values_valid <- c(1, 2, 3, 4)
values_check <- !values_data %in% values_valid

# Identify errors
errors_FuelsFine_TransNum <- qaqc(data, query, query_message, values_check)
```

-   Check that Azimuth values are reasonable.

```{r}
# Set parameters
data <- FuelsFine_data
query <- "Fuel Fine Values Azimuth"
query_message <- "Azimuth"
values_data <- data$Azimuth
values_valid <- seq(0, 359, by = 1)
values_check <- !values_data %in% values_valid

# Identify errors
errors_FuelsFine_Azimuth <- qaqc(data, query, query_message, values_check)
```

-   Check that Slope values are reasonable.

```{r}
# Set parameters
data <- FuelsFine_data
query <- "Fuel Fine Values Slope"
query_message <- "Slope"
values_data <- data$Slope
values_valid <- seq(0, 90, by = 1)
values_check <- !values_data %in% values_valid

# Identify errors
errors_FuelsFine_Slope <- qaqc(data, query, query_message, values_check)
```

-   Check that One Hour values are reasonable.

```{r}
# Perform Rosner's Test for outliers.
# This test is most appropriate when the sample size is large (n > 20). 
# Valid values were found by using the Rosner test on the full suite of data.
# Refer to the script 2_QAQC_Rosner.Rmd

# Set parameters 
data <- FuelsFine_data
query <- "Fuel Fine Values OneHr" 
query_message <- "One Hour Count" 
values_data <- data$OneHr
values_valid <- seq(0, 64, by = 1)
values_check <- !values_data %in% values_valid

# Identify errors
errors_FuelsFine_OneHr <- qaqc(data, query, query_message, values_check)
```

-   Check that Ten Hour values are reasonable.

```{r}
# Perform Rosner's Test for outliers.
# This test is most appropriate when the sample size is large (n > 20). 
# Valid values were found by using the Rosner test on the full suite of data.
# Refer to the script 2_QAQC_Rosner.Rmd

# Set parameters 
data <- FuelsFine_data
query <- "Fuel Fine Values TenHr" 
query_message <- "Ten Hour Count" 
values_data <- data$TenHr
values_valid <- seq(0, 26, by = 1)
values_check <- !values_data %in% values_valid

# Identify errors
errors_FuelsFine_TenHr <- qaqc(data, query, query_message, values_check)
```

-   Check that Hundred Hour values are reasonable.

```{r}
# Perform Rosner's Test for outliers.
# This test is most appropriate when the sample size is large (n > 20). 
# Valid values were found by using the Rosner test on the full suite of data.
# Refer to the script 2_QAQC_Rosner.Rmd

# Set parameters 
data <- FuelsFine_data
query <- "Fuel Fine Values HunHr" 
query_message <- "Hundred Hour Count" 
values_data <- data$HunHr
values_valid <- seq(0, 15, by = 1)
values_check <- !values_data %in% values_valid

# Identify errors
errors_FuelsFine_HunHr <- qaqc(data, query, query_message, values_check)
```

### Fuel Fine Errors

```{r}
# Save to master error list 
errors_FuelsFine <- rbind(errors_FuelsFine_FuelConst, errors_FuelsFine_NumTran,
                          errors_FuelsFine_OneHrTranLen, errors_FuelsFine_TenHrTranLen,
                          errors_FuelsFine_HunHrTranLen, errors_FuelsFine_Hits,
                          errors_FuelsFine_TransNum, errors_FuelsFine_Azimuth, 
                          errors_FuelsFine_Slope, errors_FuelsFine_OneHr, 
                          errors_FuelsFine_TenHr, errors_FuelsFine_HunHr)

remove(errors_FuelsFine_FuelConst, errors_FuelsFine_NumTran, errors_FuelsFine_OneHrTranLen,
       errors_FuelsFine_TenHrTranLen, errors_FuelsFine_HunHrTranLen, errors_FuelsFine_Hits,
       errors_FuelsFine_TransNum, errors_FuelsFine_Azimuth, errors_FuelsFine_Slope,
       errors_FuelsFine_OneHr, errors_FuelsFine_TenHr, errors_FuelsFine_HunHr)

# Table of results for quick check
kable(errors_FuelsFine, "pipe")

# Save as CSV or XLSX 
path_errors
#write.csv(errors_FuelsFine, paste0(path_errors, "errors_FuelsFine.csv"), quote=FALSE, row.names = FALSE, na = "") 
#write_xlsx(errors_FuelsFine, paste0(path_errors, "errors_FuelsFine.xlsx"))
```

# PROTOCOL - POST BURN

This code conducts quality control checks on post burn data within the post burn severity data set.

It checks for: header info (number of transects, length of transects, number of points per transect), substrate and vegetation values.

### PBSev Header

[Problem:]{.underline} Incorrect header information entered for FMH plots.

[Procedure:]{.underline}

-   Check that NumTran = 4

```{r}
# # Set parameters  
# data <- PostBurn_header
# query <- "PBSev Header NumTran" 
# query_message <- "Number of Transects"  
# values_data <- data$NumTran  
# values_valid <- 4    
# values_check <- !values_data == values_valid
# 
# # Identify errors
# errors_PostBurn_NumTran <- qaqc(data, query, query_message, values_check)
```

-   Check that TranLen = 50

```{r}
# # Set parameters 
# data <- PostBurn_header
# query <- "PBSev Header TranLen" 
# query_message <- "Transect Length" 
# values_data <- data$TranLen 
# values_valid <- 50  
# values_check <- !values_data == values_valid
# 
# # Identify errors
# errors_PostBurn_TranLen <- qaqc(data, query, query_message, values_check)
```

-   Check that NumPtsTran = 10

```{r}
# # Set parameters 
# data <- PostBurn_header
# query <- "PBSev Header NumPtsTran" 
# query_message <- "Number of Points" 
# values_data <- data$NumPtsTran
# values_valid <- 10
# values_check <- !values_data == values_valid
# 
# # Identify errors
# errors_PostBurn_NumPtsTran <- qaqc(data, query, query_message, values_check)
```

### PBSev Hits

[Problem:]{.underline} Extra or missing data points in FMH plots. There should be 4 transects with 10 sample points per transect.

[Procedure:]{.underline}

-   Group by Macroplot. Calculate number of hits per plot. Check that sum_hits = 40

```{r}
# # Filter NA values. Add number of hits and store in new column
# data_temp <- PostBurn_data %>%
#   filter(!is.na(Point)) %>% 
#   group_by(MacroPlot.Name) %>% 
#   summarize("sum_hits" = n())
# 
# # Set parameters 
# data <- merge(PostBurn_data, data_temp, all.x = T)
# query <- "PBSev Hits" 
# query_message <- "Number of Hits" 
# values_data <- data$sum_hits
# values_valid <- 40
# values_check <- !values_data == values_valid
# 
# # Identify errors
# errors_PostBurn_Hits <- qaqc(data, query, query_message, values_check)
#
# errors_PostBurn_Hits <- errors_PostBurn_Hits %>% 
#   reframe("SavedQuery" = unique(query),
#           "MacroPlot.Name" = unique(MacroPlot.Name), 
#           "Date" = unique(Date),
#           "Error" = unique(Error),
#           "Comment" = unique(Comment)) 
```

### PBSev Substrate

[Problem:]{.underline} Incorrect values entered for substrate severity.

[Procedure:]{.underline}

-   Check that Sub = 0, 1, 2, 3, 4, or 5

```{r}
# # Set parameters
# data <- PostBurn_data
# query <- "PBSev Substrate"
# query_message <- "Substrate Severity"
# values_data <- data$Sub
# values_valid <- c(0, 1, 2, 3, 4, 5)
# values_check <- !values_data %in% values_valid
# 
# # Identify errors
# errors_PostBurn_Sub <- qaqc(data, query, query_message, values_check)
```

### PBSev Veg

[Problem:]{.underline} Incorrect values entered for vegetation severity.

[Procedure:]{.underline}

-   Check that Veg = 0, 1, 2, 3, 4, or 5

```{r}
# # Set parameters
# data <- PostBurn_data
# query <- "PBSev Veg"
# query_message <- "Vegetation Severity"
# values_data <- data$Veg
# values_valid <- c(0, 1, 2, 3, 4, 5)
# values_check <- !values_data %in% values_valid
# 
# # Identify errors
# errors_PostBurn_Veg <- qaqc(data, query, query_message, values_check)
```

### PBSev Errors

```{r}
# # Save to master error list 
# errors_PostBurn <- rbind(errors_PostBurn_NumTran, errors_PostBurn_TranLen, 
#                          errors_PostBurn_NumPtsTran, errors_PostBurn_Hits, 
#                          errors_PostBurn_Sub, errors_PostBurn_Veg)
# 
# remove(errors_PostBurn_NumTran, errors_PostBurn_TranLen, 
#        errors_PostBurn_NumPtsTran, errors_PostBurn_Hits, 
#        errors_PostBurn_Sub, errors_PostBurn_Veg)
# 
# # Table of results for quick check
# kable(errors_PostBurn, "pipe")
# 
# # Save as CSV or XLSX 
# path_errors
# #write.csv(errors_PostBurn, paste0(path_errors, "errors_PostBurn.csv"), quote=FALSE, row.names = FALSE, na = "") 
# #write_xlsx(errors_PostBurn, paste0(path_errors, "errors_PostBurn.xlsx"))
```

# PROTOCOL - TREES

### Trees Header

[Problem:]{.underline} Incorrect header information entered for FMH plots.

[Procedure:]{.underline}

-   Check that MacroPlotSize = 0.1

```{r}
# Set parameters  
data <- Trees_header
query <- "Trees Header MacroPlotSize" 
query_message <- "Macro Plot Size"  
values_data <- data$MacroPlotSize  
values_valid <- 0.1    
values_check <- !values_data == values_valid

# Identify errors
errors_Trees_MacroPlotSize <- qaqc(data, query, query_message, values_check)
```

-   Check that SnagPlotSize = 0.1

```{r}
# Set parameters  
data <- Trees_header
query <- "Trees Header SnagPlotSize" 
query_message <- "Snag Plot Size"  
values_data <- data$SnagPlotSize
values_valid <- 0.1    
values_check <- !values_data == values_valid

# Identify errors
errors_Trees_SnagPlotSize <- qaqc(data, query, query_message, values_check)
```

-   Check that BrkPntDia = 15

```{r}
# Set parameters  
data <- Trees_header
query <- "Trees Header BrkPntDia" 
query_message <- "Break Point Diameter"  
values_data <- data$BrkPntDia
values_valid <- 15
values_check <- !values_data == values_valid

# Identify errors
errors_Trees_BrkPntDia <- qaqc(data, query, query_message, values_check)
```

#### Combine Header Errors

```{r}
# Save to master error list 
errors_Trees_Header <- rbind(errors_Trees_MacroPlotSize, errors_Trees_SnagPlotSize, 
                             errors_Trees_BrkPntDia)

remove(errors_Trees_MacroPlotSize, errors_Trees_SnagPlotSize, errors_Trees_BrkPntDia)
```

### Trees CBH

[Problem]{.underline}: Dead trees have live crown base height entered.

[Procedure:]{.underline}

-   Sort by Status. If Status = D, then check that LiCrBHt = blank

```{r}
data <- Trees_data %>% 
  filter(Status == "D")
data$LiCrBHt[is.na(data$LiCrBHt)] <- ""
query <- "Trees Dead CBH" 
query_message <- "Live Crown Base Height"  
values_data <- data$LiCrBHt
values_valid <- ""
values_check <- !values_data == values_valid

# Identify errors
errors_Trees_Dead_LiCrBHt <- qaqc(data, query, query_message, values_check)
```

#### Combine CBH Errors

```{r}
# Combine
errors_Trees_CBH <- rbind(errors_Trees_Dead_LiCrBHt)

remove(errors_Trees_Dead_LiCrBHt)
```

### Trees Crown Class

[Problem]{.underline}: Incompatible values entered for tree crown class.

[Procedure:]{.underline}

-   Sort by DBH. If DBH = blank and Status = D, then check that CrwnCl = BBD, CUS, or DD or blank

```{r}
# Set parameters  
data <- Trees_data %>% 
  filter(is.na(DBH), Status == "D")
query <- "Trees Crown Class D" 
query_message <- "Crown Class"  
values_data <- data$CrwnCl
values_valid <- c("BBD", "CUS", "DD")
values_check <- !values_data %in% values_valid

# Identify errors
errors_Trees_CrwnCl_1 <- qaqc(data, query, query_message, values_check)
```

-   Sort by DBH. If DBH = blank and Status = L, then check that CrwnCl = blank

```{r}
data <- Trees_data %>% 
  filter(is.na(DBH), Status == "L")
query <- "Trees Crown Class L" 
query_message <- "Crown Class"  
values_data <- data$CrwnCl
values_valid <- ""
values_check <- !values_data == values_valid

# Identify errors
errors_Trees_CrwnCl_2 <- qaqc(data, query, query_message, values_check)
```

-   Sort by DBH. If DBH = overstory and Status = D, then check that CrwnCl = BAD, CS, LBS, or RS or blank

```{r}
data <- Trees_data %>% 
  filter(DBH > 15.0, Status == "D")
query <- "Trees Crown Class Overstory D" 
query_message <- "Crown Class"  
values_data <- data$CrwnCl
values_valid <- c("BAD", "CS", "LBS", "RS")
values_check <- !values_data %in% values_valid

# Identify errors
errors_Trees_CrwnCl_3 <- qaqc(data, query, query_message, values_check)
```

-   Sort by DBH. If DBH = overstory and Status = L, then check that CrwnCl = C, D, I, O, or SC or blank

```{r}
data <- Trees_data %>% 
  filter(DBH > 15.0, Status == "L")
query <- "Trees Crown Class Overstory L" 
query_message <- "Crown Class"  
values_data <- data$CrwnCl
values_valid <- c("C", "D", "I", "O", "SC")
values_check <- !values_data %in% values_valid

# Identify errors
errors_Trees_CrwnCl_4 <- qaqc(data, query, query_message, values_check)
```

-   Sort by DBH. If DBH = pole, then check that CrwnCl = X or blank

```{r}
data <- Trees_data %>% 
  filter(DBH <= 15.0)
query <- "Trees Crown Class Pole" 
query_message <- "Crown Class"  
values_data <- data$CrwnCl
values_valid <- c("X", "")
values_check <- !values_data %in% values_valid

# Identify errors
errors_Trees_CrwnCl_5 <- qaqc(data, query, query_message, values_check)
```

#### Combine Crown Class Errors

```{r}
# Save to master error list 
errors_Trees_CrwnCl <- rbind(errors_Trees_CrwnCl_1, errors_Trees_CrwnCl_2, 
                             errors_Trees_CrwnCl_3, errors_Trees_CrwnCl_4, 
                             errors_Trees_CrwnCl_5)

remove(errors_Trees_CrwnCl_1, errors_Trees_CrwnCl_2, errors_Trees_CrwnCl_3, 
       errors_Trees_CrwnCl_4, errors_Trees_CrwnCl_5)
```

### Trees Damage Live

[Problem]{.underline}: Tree damage codes are entered incorrectly.

[Procedure:]{.underline}

-   Sort by DamCd 1. Check that DamCd 1 corresponds to one of the choices on the FMH-1 overstory data sheets.

```{r}
# Make sure damage codes are blank vs NA
Trees_data$DamCd1[is.na(Trees_data$DamCd1)] <- ""
Trees_data$DamCd2[is.na(Trees_data$DamCd2)] <- ""
Trees_data$DamCd3[is.na(Trees_data$DamCd3)] <- ""
Trees_data$DamCd4[is.na(Trees_data$DamCd4)] <- ""
Trees_data$DamCd5[is.na(Trees_data$DamCd5)] <- ""
```

```{r}
data <- Trees_data %>% 
  filter(Status == "L")
query <- "Trees Damage Live" 
query_message <- "Damage Code 1"  
values_data <- data$DamCd1
values_valid <- c("", "ABGR", "BIRD", "BLIG", "BROK", "BROM", "BURL", "CONK", "CROK", "DTOP", "EPIC", "EPIP", "FIRE", "FORK", "FRST", "GALL", "HOLW", "INSE", "LEAN", "LICH", "LIGT", "MAMM", "MISL", "MOSS", "OZON", "ROOT", "ROTT", "SPAR", "SPRT", "TWIN", "UMAN", "WOND")
values_check <- !values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_L_1 <- qaqc(data, query, query_message, values_check)
```

-   Sort by DamCd 2. Check that DamCd 2 corresponds to one of the choices on the FMH-1 overstory data sheets.

```{r}
data <- Trees_data %>% 
  filter(Status == "L")
query <- "Trees Damage Live" 
query_message <- "Damage Code 2"  
values_data <- data$DamCd2
values_valid <- c("", "ABGR", "BIRD", "BLIG", "BROK", "BROM", "BURL", "CONK", "CROK", "DTOP", "EPIC", "EPIP", "FIRE", "FORK", "FRST", "GALL", "HOLW", "INSE", "LEAN", "LICH", "LIGT", "MAMM", "MISL", "MOSS", "OZON", "ROOT", "ROTT", "SPAR", "SPRT", "TWIN", "UMAN", "WOND")
values_check <- !values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_L_2 <- qaqc(data, query, query_message, values_check)
```

-   Sort by DamCd 3. Check that DamCd 3 corresponds to one of the choices on the FMH-1 overstory data sheets.

```{r}
data <- Trees_data %>% 
  filter(Status == "L")
query <- "Trees Damage Live" 
query_message <- "Damage Code 3"  
values_data <- data$DamCd3
values_valid <- c("", "ABGR", "BIRD", "BLIG", "BROK", "BROM", "BURL", "CONK", "CROK", "DTOP", "EPIC", "EPIP", "FIRE", "FORK", "FRST", "GALL", "HOLW", "INSE", "LEAN", "LICH", "LIGT", "MAMM", "MISL", "MOSS", "OZON", "ROOT", "ROTT", "SPAR", "SPRT", "TWIN", "UMAN", "WOND")
values_check <- !values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_L_3 <- qaqc(data, query, query_message, values_check)
```

-   Sort by DamCd 4. Check that DamCd 4 corresponds to one of the choices on the FMH-1 overstory data sheets.

```{r}
data <- Trees_data %>% 
  filter(Status == "L")
query <- "Trees Damage Live" 
query_message <- "Damage Code 4"  
values_data <- data$DamCd4
values_valid <- c("", "ABGR", "BIRD", "BLIG", "BROK", "BROM", "BURL", "CONK", "CROK", "DTOP", "EPIC", "EPIP", "FIRE", "FORK", "FRST", "GALL", "HOLW", "INSE", "LEAN", "LICH", "LIGT", "MAMM", "MISL", "MOSS", "OZON", "ROOT", "ROTT", "SPAR", "SPRT", "TWIN", "UMAN", "WOND")
values_check <- !values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_L_4 <- qaqc(data, query, query_message, values_check)
```

-   Sort by DamCd 5. Check that DamCd 5 corresponds to one of the choices on the FMH-1 overstory data sheets.

```{r}
data <- Trees_data %>% 
  filter(Status == "L")
query <- "Trees Damage Live" 
query_message <- "Damage Code 5"  
values_data <- data$DamCd5
values_valid <- c("", "ABGR", "BIRD", "BLIG", "BROK", "BROM", "BURL", "CONK", "CROK", "DTOP", "EPIC", "EPIP", "FIRE", "FORK", "FRST", "GALL", "HOLW", "INSE", "LEAN", "LICH", "LIGT", "MAMM", "MISL", "MOSS", "OZON", "ROOT", "ROTT", "SPAR", "SPRT", "TWIN", "UMAN", "WOND")
values_check <- !values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_L_5 <- qaqc(data, query, query_message, values_check)
```

### Trees Damage Dead

[Problem]{.underline}: Damage codes entered for trees that are dead.

[Procedure:]{.underline}

-   Sort by Status. If Status = D, check that DamCd1, DamCd2, DamCd3, DamCd4, [and]{.underline} DamCd5 are blank.

```{r}
data <- Trees_data %>% 
  filter(Status == "D")
query <- "Trees Damage Dead" 
query_message <- "Damage Code 1"  
values_data <- data$DamCd1
values_valid <- ""
values_check <- !values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_D_1 <- qaqc(data, query, query_message, values_check)
```

```{r}
data <- Trees_data %>% 
  filter(Status == "D")
query <- "Trees Damage Dead" 
query_message <- "Damage Code 2"  
values_data <- data$DamCd2
values_valid <- ""
values_check <- !values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_D_2 <- qaqc(data, query, query_message, values_check)
```

```{r}
data <- Trees_data %>% 
  filter(Status == "D")
query <- "Trees Damage Dead" 
query_message <- "Damage Code 3"  
values_data <- data$DamCd3
values_valid <- ""
values_check <- !values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_D_3 <- qaqc(data, query, query_message, values_check)
```

```{r}
data <- Trees_data %>% 
  filter(Status == "D")
query <- "Trees Damage Dead" 
query_message <- "Damage Code 4"  
values_data <- data$DamCd4
values_valid <- ""
values_check <- !values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_D_4 <- qaqc(data, query, query_message, values_check)
```

```{r}
data <- Trees_data %>% 
  filter(Status == "D")
query <- "Trees Damage Dead" 
query_message <- "Damage Code 5"  
values_data <- data$DamCd5
values_valid <- ""
values_check <- !values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_D_5 <- qaqc(data, query, query_message, values_check)
```

### Trees Damage Blank

[Problem]{.underline}: Tree damage codes are entered incorrectly. Blank damages exist before entered damages

[Procedure:]{.underline}

-   Filter for DamCd1 = blank. Check that DamCd2, DamCd3, DamCd4, [and]{.underline} DamCd5 are blank.

```{r}
data <- Trees_data %>% 
  filter(DamCd1 == "")
query <- "Trees Damage Blank" 
query_message <- "Damage Code 1 = Blank, Damage Code 2"  
values_data <- data$DamCd2
values_valid <- ""
values_check <- !values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_1_Blank_2 <- qaqc(data, query, query_message, values_check)
```

```{r}
data <- Trees_data %>% 
  filter(DamCd1 == "")
query <- "Trees Damage Blank" 
query_message <- "Damage Code 1 = Blank, Damage Code 3"  
values_data <- data$DamCd3
values_valid <- ""
values_check <- !values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_1_Blank_3 <- qaqc(data, query, query_message, values_check)
```

```{r}
data <- Trees_data %>% 
  filter(DamCd1 == "")
query <- "Trees Damage Blank" 
query_message <- "Damage Code 1 = Blank, Damage Code 4"  
values_data <- data$DamCd4
values_valid <- ""
values_check <- !values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_1_Blank_4 <- qaqc(data, query, query_message, values_check)
```

```{r}
data <- Trees_data  %>% 
  filter(DamCd1 == "")
query <- "Trees Damage Blank" 
query_message <- "Damage Code 1 = Blank, Damage Code 5"  
values_data <- data$DamCd5
values_valid <- ""
values_check <- !values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_1_Blank_5 <- qaqc(data, query, query_message, values_check)
```

-   Filter for DamCd2 = blank. Check that DamCd3, DamCd4, [and]{.underline} DamCd5 are blank.

```{r}
data <- Trees_data %>% 
  filter(DamCd2 == "")
query <- "Trees Damage Blank" 
query_message <- "Damage Code 2 = Blank, Damage Code 3"  
values_data <- data$DamCd3
values_valid <- ""
values_check <- !values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_2_Blank_3 <- qaqc(data, query, query_message, values_check)
```

```{r}
data <- Trees_data %>% 
  filter(DamCd2 == "")
query <- "Trees Damage Blank" 
query_message <- "Damage Code 2 = Blank, Damage Code 4"  
values_data <- data$DamCd4
values_valid <- ""
values_check <- !values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_2_Blank_4 <- qaqc(data, query, query_message, values_check)
```

```{r}
data <- Trees_data %>% 
  filter(DamCd2 == "")
query <- "Trees Damage Blank" 
query_message <- "Damage Code 2 = Blank, Damage Code 5"  
values_data <- data$DamCd5
values_valid <- ""
values_check <- !values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_2_Blank_5 <- qaqc(data, query, query_message, values_check)
```

-   Filter for DamCd3 = blank. Check that DamCd4 [and]{.underline} DamCd5 are blank.

```{r}
data <- Trees_data %>% 
  filter(DamCd3 == "")
query <- "Trees Damage Blank" 
query_message <- "Damage Code 3 = Blank, Damage Code 4"  
values_data <- data$DamCd4
values_valid <- ""
values_check <- !values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_3_Blank_4 <- qaqc(data, query, query_message, values_check)
```

```{r}
data <- Trees_data %>% 
  filter(DamCd3 == "")
query <- "Trees Damage Blank" 
query_message <- "Damage Code 3 = Blank, Damage Code 5"  
values_data <- data$DamCd5
values_valid <- ""
values_check <- !values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_3_Blank_5 <- qaqc(data, query, query_message, values_check)
```

-   Filter for DamCd4 = blank. Check that DamCd5 is blank.

```{r}
data <- Trees_data %>% 
  filter(DamCd4 == "")
query <- "Trees Damage Blank" 
query_message <- "Damage Code 4 = Blank, Damage Code 5"  
values_data <- data$DamCd5
values_valid <- ""
values_check <- !values_data %in% values_valid

# Identify errors
errors_Trees_DamCd_4_Blank_5 <- qaqc(data, query, query_message, values_check)
```

#### Combine Damage Errors

```{r}
# Damage Errors Live Trees
errors_Trees_DamCd_L <- unique(rbind(errors_Trees_DamCd_L_1, errors_Trees_DamCd_L_2, 
                              errors_Trees_DamCd_L_3, errors_Trees_DamCd_L_4, 
                              errors_Trees_DamCd_L_5))

remove(errors_Trees_DamCd_L_1, errors_Trees_DamCd_L_2, errors_Trees_DamCd_L_3, 
       errors_Trees_DamCd_L_4, errors_Trees_DamCd_L_5)

# Damage Errors Dead Trees
errors_Trees_DamCd_D <- unique(rbind(errors_Trees_DamCd_D_1, errors_Trees_DamCd_D_2, 
                            errors_Trees_DamCd_D_3, errors_Trees_DamCd_D_4, 
                            errors_Trees_DamCd_D_5))

remove(errors_Trees_DamCd_D_1, errors_Trees_DamCd_D_2, errors_Trees_DamCd_D_3, 
       errors_Trees_DamCd_D_4, errors_Trees_DamCd_D_5)

# Damage Errors Blank Entries
errors_Trees_DamCd_Blank <- unique(rbind(errors_Trees_DamCd_1_Blank_2, errors_Trees_DamCd_1_Blank_3, errors_Trees_DamCd_1_Blank_4, errors_Trees_DamCd_1_Blank_5, errors_Trees_DamCd_2_Blank_3, errors_Trees_DamCd_2_Blank_4, errors_Trees_DamCd_2_Blank_5, errors_Trees_DamCd_3_Blank_4, errors_Trees_DamCd_3_Blank_5, errors_Trees_DamCd_4_Blank_5))

remove(errors_Trees_DamCd_1_Blank_2, errors_Trees_DamCd_1_Blank_3,
       errors_Trees_DamCd_1_Blank_4, errors_Trees_DamCd_1_Blank_5, 
       errors_Trees_DamCd_2_Blank_3, errors_Trees_DamCd_2_Blank_4, 
       errors_Trees_DamCd_2_Blank_5, errors_Trees_DamCd_3_Blank_4, 
       errors_Trees_DamCd_3_Blank_5, errors_Trees_DamCd_4_Blank_5)

# Damage Errors Combined
errors_Trees_DamCd <- rbind(errors_Trees_DamCd_L, errors_Trees_DamCd_D, 
                            errors_Trees_DamCd_Blank)

remove(errors_Trees_DamCd_L, errors_Trees_DamCd_D, errors_Trees_DamCd_Blank)
                                  
```

### Trees DBH

[Problem]{.underline}: DBH values smaller than sampling parameters or excessively large. DBH values for standing trees do not exist.

[Procedure:]{.underline}

-   Filter to exclude DD trees. Check that DBH ≥ 2.5.

```{r}
data <- Trees_data %>% 
  filter(CrwnCl != "DD")
query <- "Trees DBH Min" 
query_message <- "DBH"  
values_data <- data$DBH
values_valid <- min(2.5)
values_check <- !values_data >= values_valid

# Identify errors
errors_Trees_DBH_Min <- qaqc(data, query, query_message, values_check)
```

-   Filter to exclude DD trees. Check that DBH is not excessively large. Check that DBH values for standing trees exist.

```{r}
# Perform Rosner's Test for outliers.
# This test is most appropriate when the sample size is large (n > 20). 
# Valid values were found by using the Rosner test on the full suite of data.
# Refer to the script 2_QAQC_Rosner.Rmd

data <- Trees_data %>% 
  filter(CrwnCl != "DD")
query <- "Trees DBH Max" 
query_message <- "DBH"  
values_data <- data$DBH
values_valid <- max(118)
values_check <- !values_data <= values_valid

# Identify errors
errors_Trees_DBH_Max <- qaqc(data, query, query_message, values_check)
```

#### Combine DBH Errors

```{r}
# Combine
errors_Trees_DBH <- rbind(errors_Trees_DBH_Min, errors_Trees_DBH_Max)

remove(errors_Trees_DBH_Min, errors_Trees_DBH_Max)
```

### Trees DD

[Problem]{.underline}: DBH, height, and or crown base height entered for trees that are no longer standing.

[Procedure:]{.underline}

-   Filter for CrwnCl = BBD, CUS, or DD. Check that DBH, Ht, [and]{.underline} LiCrBHt are blank

```{r}
data <- Trees_data %>% 
  filter(CrwnCl == c("BBD", "CUS", "DD"))
data$DBH[is.na(data$DBH)] <- ""
query <- "Trees DD DBH" 
query_message <- "DBH"  
values_data <- data$DBH
values_valid <- ""
values_check <- !values_data == values_valid

# Identify errors
errors_Trees_DD_DBH <- qaqc(data, query, query_message, values_check)
```

```{r}
data <- Trees_data %>% 
  filter(CrwnCl == c("BBD", "CUS", "DD"))
data$Ht[is.na(data$Ht)] <- ""
query <- "Trees DD Ht" 
query_message <- "Height"  
values_data <- data$Ht
values_valid <- ""
values_check <- !values_data == values_valid

# Identify errors
errors_Trees_DD_Ht <- qaqc(data, query, query_message, values_check)
```

```{r}
data <- Trees_data %>% 
  filter(CrwnCl == c("BBD", "CUS", "DD"))
data$LiCrBHt[is.na(data$LiCrBHt)] <- ""
query <- "Trees DD CBH" 
query_message <- "Live Crown Base Height"  
values_data <- data$LiCrBHt
values_valid <- ""
values_check <- !values_data == values_valid

# Identify errors
errors_Trees_DD_LiCrBHt <- qaqc(data, query, query_message, values_check)
```

#### Combine DD Errors

```{r}
# Combine
errors_Trees_DD <- rbind(errors_Trees_DD_DBH, errors_Trees_DD_Ht, 
                         errors_Trees_DD_LiCrBHt)

remove(errors_Trees_DD_DBH, errors_Trees_DD_Ht, errors_Trees_DD_LiCrBHt)
```

### Trees Duplicates

[Problem]{.underline}: Duplicate tree tag numbers entered for a plot visit.

[Note:]{.underline} FFI query not capturing all duplicates. Need to revise query. (check PIED plots - PIED02 especially). Need to categorize by pole and overstory trees

[Procedure:]{.underline}

-   Sort by RowCount. Check that RowCount = 1 for all entries.

```{r}
# Check for tag duplication (TRUE/FALSE) and store results in new column
data_temp <- Trees_data %>%
  group_by(MacroPlot.Name, TagNo) %>% 
  mutate("Duplicate" = duplicated(TagNo))

data <- merge(Trees_data, data_temp, all.x = T)
data$Duplicate[is.na(data$Duplicate)] <- ""
query <- "Trees Duplicates" 
query_message <- "Duplicate Tag"  
values_data <- data$Duplicate
values_valid <- FALSE
values_check <- !values_data == values_valid

# Identify errors
errors_Trees_Duplicate <- qaqc(data, query, query_message, values_check)
```

### Trees Frac

[Problem:]{.underline} Incorrect subplot fraction entered for trees.

[Note:]{.underline} In some cases pole SubFrac will differ from 0.5 if a smaller area was sampled in a particular year. Check yearly procedures to confirm correct values.

[Procedure:]{.underline}

-   If DBH = overstory, then check that SubFrac = 1

```{r}
data <- Trees_data %>% 
   filter(DBH > 15.0)
query <- "Trees Frac Overstory" 
query_message <- "Subplot Fraction"  
values_data <- data$SubFrac
values_valid <- 1
values_check <- !values_data == values_valid

# Identify errors
errors_Trees_Frac_Overstory <- qaqc(data, query, query_message, values_check)
```

-   If DBH = pole, then check that SubFrac = 0.5

```{r}
data <- Trees_data %>% 
  filter(DBH <= 15.0)
query <- "Trees Frac Pole" 
query_message <- "Subplot Fraction"  
values_data <- data$SubFrac
values_valid <- 0.5
values_check <- !values_data == values_valid

# Identify errors
errors_Trees_Frac_Pole <- qaqc(data, query, query_message, values_check)

errors_Trees_Frac_Pole <- errors_Trees_Frac_Pole %>% 
  reframe("SavedQuery" = unique(query),
          "MacroPlot.Name" = unique(MacroPlot.Name), 
          "Date" = unique(Date),
          "Error" = unique(Error),
          "Comment" = unique(Comment)) 
```

#### Combine Frac Errors

```{r}
# Combine
errors_Trees_Frac <- rbind(errors_Trees_Frac_Overstory, errors_Trees_Frac_Pole)

remove(errors_Trees_Frac_Overstory, errors_Trees_Frac_Pole)
```

### Trees Height

[Problem:]{.underline} Incorrect values entered for height. Pole trees should correspond to an established height class. Overstory trees should have reasonable height values.

[Procedure:]{.underline}

-   Filter for Overstory trees. Check that Ht is not excessively large.

```{r}
# Perform Rosner's Test for outliers.
# This test is most appropriate when the sample size is large (n > 20). 
# Valid values were found by using the Rosner test on the full suite of data.
# Refer to the script 2_QAQC_Rosner.Rmd

data <- Trees_data %>% 
   filter(DBH > 15.0)
query <- "Trees Height Overstory" 
query_message <- "Height"  
values_data <- data$Ht
values_valid <- max(45)
values_check <- !values_data <= values_valid

# Identify errors
errors_Trees_Height_Overstory <- qaqc(data, query, query_message, values_check)
```

-   Filter for Pole trees. Check that Ht = 0.6, 1, 2, 3, 4, 5, 6, 7, 8, 9, or 10 or blank.

```{r}
data <- Trees_data %>% 
  filter(DBH <= 15.0)
query <- "Trees Height Pole" 
query_message <- "Height"  
values_data <- data$Ht
values_valid <- c("", 0.6, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
values_check <- !values_data %in% values_valid

# Identify errors
errors_Trees_Height_Pole <- qaqc(data, query, query_message, values_check)
```

#### Combine Height Errors

```{r}
# Combine
errors_Trees_Height <- rbind(errors_Trees_Height_Overstory, errors_Trees_Height_Pole)

remove(errors_Trees_Height_Overstory, errors_Trees_Height_Pole)
```

### Trees Life Form

[Problem:]{.underline} Species entered that are not trees.

[Procedure:]{.underline}

-   Check that Preferred Lifeform = Tree

```{r}
data <- Trees_data
query <- "Trees Life Form" 
query_message <- "Life Form"  
values_data <- data$Preferred_Lifeform
values_valid <- "Tree"
values_check <- !values_data == values_valid

# Identify errors
errors_Trees_LifeForm <- qaqc(data, query, query_message, values_check)
```

### Trees Non-Post Severity

[Problem]{.underline}: Scorch height, scorch %, and/or char height are entered in sample events other than immediate post for FMH plots. These values should only be collected at immediate post reads.

[Procedure:]{.underline}

-   Filter to exclude all POST reads (01Post, 02Post, etc). Check that CharHt = blank, ScorchHt = blank, [and]{.underline} CrScPct = blank (i.e. no records should appear in the query)

```{r}
data <- Trees_data %>% 
  filter(!Monitoring.Status %in% c("01Post", "02Post", "03Post", "04Post"))
data$CharHt[is.na(data$CharHt)] <- ""
query <- "Trees Non-Post Severity CharHt" 
query_message <- "Char Height"  
values_data <- data$CharHt
values_valid <- ""
values_check <- !values_data == values_valid

# Identify errors
errors_Trees_NonPost_Severity_CharHt <- qaqc(data, query, query_message, values_check)
```

```{r}
data <- Trees_data %>% 
  filter(!Monitoring.Status %in% c("01Post", "02Post", "03Post", "04Post"))
data$ScorchHt[is.na(data$ScorchHt)] <- ""
query <- "Trees Non-Post Severity ScorchHt" 
query_message <- "Scorch Height"  
values_data <- data$ScorchHt
values_valid <- "NA"
values_check <- !values_data == values_valid

# Identify errors
errors_Trees_NonPost_Severity_ScorchHt <- qaqc(data, query, query_message, values_check)
```

```{r}
data <- Trees_data %>% 
  filter(!Monitoring.Status %in% c("01Post", "02Post", "03Post", "04Post"))
data$CrScPct[is.na(data$CrScPct)] <- ""
query <- "Trees Non-Post Severity CrScPct" 
query_message <- "Crown Scorch Percent"  
values_data <- data$CrScPct
values_valid <- "NA"
values_check <- !values_data == values_valid

# Identify errors
errors_Trees_NonPost_Severity_CrScPct <- qaqc(data, query, query_message, values_check)
```

#### Combine Non-Post Severity Errors

```{r}
# Combine
errors_Trees_NonPost_Severity <- rbind(errors_Trees_NonPost_Severity_CharHt, errors_Trees_NonPost_Severity_ScorchHt, errors_Trees_NonPost_Severity_CrScPct)

remove(errors_Trees_NonPost_Severity_CharHt, errors_Trees_NonPost_Severity_ScorchHt, errors_Trees_NonPost_Severity_CrScPct)
```

### Trees Post Char

[Problem]{.underline}: Char height missing or excessively large for standing trees during the immediate post-fire sample events in FMH plots. Char height entered for trees that are no longer standing.

[Procedure:]{.underline}

-   DD Trees. Filter to include all POST reads (01Post, 02Post, etc). Filter for DD crown classes (DD, BBD, and CUS). Check that CharHt = blank.

```{r}
data <- Trees_data %>% 
  filter(Monitoring.Status %in% c("01Post", "02Post", "03Post", "04Post"),
         CrwnCl %in% c("DD", "BBD", "CUS"))
data$CharHt[is.na(data$CharHt)] <- ""
query <- "Trees Post Char DD" 
query_message <- "Char Height for DD Tree"  
values_data <- data$CharHt
values_valid <- ""
values_check <- !values_data == values_valid

# Identify errors
errors_Trees_Post_Char_DD <- qaqc(data, query, query_message, values_check)
```

-   Standing Dead Trees. Filter to include all POST reads (01Post, 02Post, etc). Filter to exclude DD crown classes (DD, BBD, and CUS). Filter for Status = D. Check that CharHt is [not]{.underline} blank.

```{r}
data <- Trees_data %>% 
  filter(Monitoring.Status %in% c("01Post", "02Post", "03Post", "04Post"),
         !CrwnCl %in% c("DD", "BBD", "CUS"),
         Status == "D",
         # Blank Char Ht can have tag 0
         !TagNo == 0)
data$CharHt[is.na(data$CharHt)] <- ""
query <- "Trees Post Char Dead" 
query_message <- "Char Height for Standing Dead"  
values_data <- data$CharHt
values_valid <- ""
values_check <- values_data == values_valid

# Identify errors
errors_Trees_Post_Char_Dead <- qaqc(data, query, query_message, values_check)
```

-   Live trees. Filter to include all POST reads (01Post, 02Post, etc). Filter for Status = L. Check that CharHt is not blank or excessively high.

```{r}
# Perform Rosner's Test for outliers.
# This test is most appropriate when the sample size is large (n > 20). 
# Valid values were found by using the Rosner test on the full suite of data.
# Refer to the script 2_QAQC_Rosner.Rmd

data <- Trees_data %>% 
  filter(Monitoring.Status %in% c("01Post", "02Post", "03Post", "04Post"),
         Status == "L")
query <- "Trees Post Char Live" 
query_message <- "Char Height"  
values_data <- data$CharHt
values_valid <- max(29)
values_check <- !values_data <= values_valid

# Identify errors
errors_Trees_Post_Char_Live <- qaqc(data, query, query_message, values_check)
```

### Trees Post ScorchHt

[Problem]{.underline}: Scorch height missing or excessively large for live trees during the immediate post-fire sample events in FMH plots. Scorch height entered for trees that are no longer standing or are broken.

[Procedure:]{.underline}

-   DD Trees. Filter to include all POST reads (01Post, 02Post, etc). Filter for DD crown classes (DD, BBD, and CUS). Check that ScorchHt = blank.

```{r}
data <- Trees_data %>% 
  filter(Monitoring.Status %in% c("01Post", "02Post", "03Post", "04Post"),
         CrwnCl %in% c("DD", "BBD", "CUS"))
data$ScorchHt[is.na(data$ScorchHt)] <- ""
query <- "Trees Post Scorch DD" 
query_message <- "Scorch Height for DD Tree"  
values_data <- data$ScorchHt
values_valid <- ""
values_check <- !values_data == values_valid

# Identify errors
errors_Trees_Post_Scorch_DD <- qaqc(data, query, query_message, values_check)
```

-   Standing Dead Trees. Filter to include all POST reads (01Post, 02Post, etc). Filter to exclude DD crown classes (DD, BBD, and CUS). Filter for Status = D. Check that ScorchHt = blank.

```{r}
data <- Trees_data %>% 
  filter(Monitoring.Status %in% c("01Post", "02Post", "03Post", "04Post"),
         !CrwnCl %in% c("DD", "BBD", "CUS"),
         Status == "D")
data$ScorchHt[is.na(data$ScorchHt)] <- ""
query <- "Trees Post Scorch Dead"
query_message <- "Scorch Height for Standing Dead"  
values_data <- data$ScorchHt
values_valid <- ""
values_check <- !values_data == values_valid

# Identify errors
errors_Trees_Post_Scorch_Dead <- qaqc(data, query, query_message, values_check)
```

-   Live trees. Filter to include all POST reads (01Post, 02Post, etc). Filter for Status = L. Check that ScorchHt is not blank or excessively high.

```{r}
# Perform Rosner's Test for outliers.
# This test is most appropriate when the sample size is large (n > 20). 
# Valid values were found by using the Rosner test on the full suite of data.
# Refer to the script 2_QAQC_Rosner.Rmd

data <- Trees_data %>% 
  filter(Monitoring.Status %in% c("01Post", "02Post", "03Post", "04Post"),
         Status == "L")
query <- "Trees Post Scorch Live" 
query_message <- "Scorch Height"  
values_data <- data$ScorchHt
values_valid <- max(39)
values_check <- !values_data <= values_valid

# Identify errors
errors_Trees_Post_Scorch_Live <- qaqc(data, query, query_message, values_check)
```

### Trees Post Scorch%

[Problem]{.underline}: Scorch % missing or excessively large for live trees during the immediate post-fire sample events in FMH plots. Scorch % entered incorrectly for trees that are no longer standing.

[Procedure:]{.underline}

-   DD Trees. Filter to include all POST reads (01Post, 02Post, etc). Filter for DD crown classes (DD, BBD, and CUS). Check that CrScPct = blank.

-   Check that all rows with CrwnCl = DD have CrScPct = blank or 100. (RS?)

```{r}
data <- Trees_data %>% 
  filter(Monitoring.Status %in% c("01Post", "02Post", "03Post", "04Post"),
         CrwnCl %in% c("DD", "BBD", "CUS"))
data$CrScPct[is.na(data$CrScPct)] <- ""
query <- "Trees Post Scorch% DD" 
query_message <- "Scorch Percent for DD Tree"  
values_data <- data$CrScPct
values_valid <- ""
values_check <- !values_data == values_valid

# Identify errors
errors_Trees_Post_ScorchPct_DD <- qaqc(data, query, query_message, values_check)
```

-   Standing Dead Trees. Filter to include all POST reads (01Post, 02Post, etc). Filter to exclude DD crown classes (DD, BBD, and CUS). Filter for Status = D. Check that CrScPct = blank.

```{r}
data <- Trees_data %>% 
  filter(Monitoring.Status %in% c("01Post", "02Post", "03Post", "04Post"),
         !CrwnCl %in% c("DD", "BBD", "CUS"),
         Status == "D")
data$CrScPct[is.na(data$CrScPct)] <- ""
query <- "Trees Post Scorch% Dead"
query_message <- "Scorch Percent for Standing Dead"  
values_data <- data$CrScPct
values_valid <- ""
values_check <- !values_data == values_valid

# Identify errors
errors_Trees_Post_ScorchPct_Dead <- qaqc(data, query, query_message, values_check)
```

-   Live trees. Filter to include all POST reads (01Post, 02Post, etc). Filter for Status = L. Check that CrScPct is not blank. Check that CrScPct ≤ 100.

```{r}
data <- Trees_data %>% 
  filter(Monitoring.Status %in% c("01Post", "02Post", "03Post", "04Post"),
         Status == "L")
query <- "Trees Post Scorch% Live" 
query_message <- "Scorch Percent"  
values_data <- data$CrScPct
values_valid <- max(100)
values_check <- !values_data <= values_valid

# Identify errors
errors_Trees_Post_ScorchPct_Live <- qaqc(data, query, query_message, values_check)
```

#### Combine Post Severity Errors

```{r}
# Combine
errors_Trees_Post_Severity <- rbind(errors_Trees_Post_Char_DD, errors_Trees_Post_Char_Dead, errors_Trees_Post_Char_Live, errors_Trees_Post_Scorch_DD, errors_Trees_Post_Scorch_Dead, errors_Trees_Post_Scorch_Live, errors_Trees_Post_ScorchPct_DD, errors_Trees_Post_ScorchPct_Dead, errors_Trees_Post_ScorchPct_Live)

remove(errors_Trees_Post_Char_DD, errors_Trees_Post_Char_Dead, errors_Trees_Post_Char_Live, errors_Trees_Post_Scorch_DD, errors_Trees_Post_Scorch_Dead, errors_Trees_Post_Scorch_Live, errors_Trees_Post_ScorchPct_DD, errors_Trees_Post_ScorchPct_Dead, errors_Trees_Post_ScorchPct_Live)
```

### Trees Status

[Problem:]{.underline} Species do not have an entry for status or have an entry that we don’t use.

[Procedure:]{.underline}

-   Sort by Status. Check that Status = L or D

```{r}
data <- Trees_data
query <- "Trees Status" 
query_message <- "Status"  
values_data <- data$Status
values_valid <- c("L", "D")
values_check <- !values_data %in% values_valid

# Identify errors
errors_Trees_Status <- qaqc(data, query, query_message, values_check)
```

### Trees UV

[Problem]{.underline}: X present in the UV columns signifying respective data (DBH, Ht, or LiCrBHT) weren’t assessed.

[Procedure]{.underline}:

-   Check that UV(1, 2, [or]{.underline} 3) is blank for all plots

```{r}
data <- Trees_data
data$UV1[is.na(data$UV1)] <- ""
query <- "Trees UV1" 
query_message <- "User Variable 1"  
values_data <- data$UV1
values_valid <- ""
values_check <- !values_data == values_valid

# Identify errors
errors_Trees_UV1 <- qaqc(data, query, query_message, values_check)
```

```{r}
data <- Trees_data
data$UV2[is.na(data$UV2)] <- ""
query <- "Trees UV2" 
query_message <- "User Variable 2"  
values_data <- data$UV2
values_valid <- ""
values_check <- !values_data == values_valid

# Identify errors
errors_Trees_UV2 <- qaqc(data, query, query_message, values_check)
```

```{r}
data <- Trees_data
data$UV3[is.na(data$UV3)] <- ""
query <- "Trees UV3" 
query_message <- "User Variable 3"  
values_data <- data$UV3
values_valid <- ""
values_check <- !values_data == values_valid

# Identify errors
errors_Trees_UV3 <- qaqc(data, query, query_message, values_check)
```

#### Combine UV Errors

```{r}
# Combine
errors_Trees_UV <- rbind(errors_Trees_UV1, errors_Trees_UV2, errors_Trees_UV3)

remove(errors_Trees_UV1, errors_Trees_UV2, errors_Trees_UV3)
```

## Trees Errors

```{r}
errors_Trees <- rbind(errors_Trees_CrwnCl, errors_Trees_DamCd,
                      errors_Trees_DBH, errors_Trees_DD, errors_Trees_CBH, errors_Trees_Duplicate, 
                      errors_Trees_Frac, errors_Trees_Header, errors_Trees_Height, 
                      errors_Trees_NonPost_Severity, errors_Trees_Post_Severity, 
                      errors_Trees_Status, errors_Trees_LifeForm, errors_Trees_UV)

errors_Trees <- rbind(errors_Trees_CrwnCl, errors_Trees_DamCd,
                      errors_Trees_DBH, errors_Trees_DD, errors_Trees_CBH, errors_Trees_Duplicate, 
                      errors_Trees_Frac, errors_Trees_Header, errors_Trees_Height,
                      errors_Trees_UV)


remove(errors_Trees_Header, errors_Trees_CrwnCl, errors_Trees_DamCd,
                      errors_Trees_DBH, errors_Trees_CBH, errors_Trees_DD, errors_Trees_Duplicate, 
                      errors_Trees_Frac, errors_Trees_Height, 
                      errors_Trees_NonPost_Severity, errors_Trees_Post_Severity, 
                      errors_Trees_Status, errors_Trees_LifeForm, errors_Trees_UV)

# Table of results for quick check
#kable(errors_Trees, "pipe")

# Save as CSV or XLSX
#path_errors
#write.csv(errors_Trees, paste0(path_errors, "errors_Trees.csv"), quote=FALSE, row.names = FALSE, na = "")
#write_xlsx(errors_Trees, paste0(path_errors, "errors_Trees.xlsx"))
```

# CROSS PROTOCOL CHECKS

## 1000HR VS FINE SLOPE

This code conducts quality control checks on slope data in the surface fuels coarse woody debris (1000-hr) and fine woody debris datasets. It also checks for overall consistency in slope and azimuth values across years.

```{r}
# Set parameters 
data_Fuels1000_slope <- Fuels1000_data %>% 
  group_by(MacroPlot.Name, Date, Transect, Slope) %>% 
  summarise("MacroPlot.Name" = unique(MacroPlot.Name), 
            "Transect" = unique(Transect)) %>% 
  mutate(Slope_1000 = Slope) %>% 
  arrange(MacroPlot.Name, Transect) %>% 
  select(!Slope)

data_FuelsFine_slope <- FuelsFine_data %>% 
  group_by(MacroPlot.Name, Date, Transect, Comment, Slope) %>% 
  summarise("MacroPlot.Name" = unique(MacroPlot.Name), 
            "Transect" = unique(Transect)) %>% 
  mutate(Slope_fine = Slope) %>% 
  arrange(MacroPlot.Name, Transect) %>% 
  select(!Slope)

errors_Fuels_slope <- merge(data_Fuels1000_slope, data_FuelsFine_slope, all.y = T) %>% 
  filter(Slope_fine != Slope_1000) %>% 
  mutate(SavedQuery = "Fuel Slope",
         Error = paste("FWD slope", Slope_fine, "!=", "CWD slope", Slope_1000)) %>% 
  reframe("SavedQuery" = unique(query),
          "MacroPlot.Name" = unique(MacroPlot.Name), 
          "Date" = unique(Date), 
          "Error" = unique(Error),
          "Comment" = unique(Comment))

# If no errors, add "No Errors" to existing data frame 
if (nrow(errors_Fuels_slope) == 0) {   
    errors_Fuels_slope <- errors_blank %>%     
    mutate(SavedQuery = query) 
} else {   
    errors_Fuels_slope <- errors_Fuels_slope
}
```

# CROSS YEAR CHECKS

## Trees Dead to Alive

## Trees Changing DBH

# ALL ERRORS

```{r}
# Save to master error list 
errors_all <- rbind(errors_Fuels1000, errors_FuelsDuffLitt, 
                    errors_FuelsFine, errors_Fuels_slope,
                    errors_PostBurn, errors_Trees)

# Table of results for quick check
kable(errors_all, "pipe")

# Save as CSV or XLSX 
path_errors
#write.csv(errors, paste0(path_errors, "errors_all.csv"), quote=FALSE, row.names = FALSE, na = "") 
#write_xlsx(errors_all, paste0(path_errors, "errors_all.xlsx"))
```
